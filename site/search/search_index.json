{
    "docs": [
        {
            "location": "/", 
            "text": "eac.js\n\n\nA library and a command line execution tool for working with the \nEthereum Alarm Clock\n protocol. \n\n\nInstall\n\n\nAs an executable\n\n\nThe \neac.js\n executable can be downloaded from NPM. \n\n\n$ npm i -g eac.js\n\n\n\n\nPlease proceed to \nExecuting\n for a walkthrough on how to get started.\n\n\nAs a library\n\n\nIf you are using eac.js as a library you will want to download it into your \npackage.json\n file.\n\n\n$ npm i eac.js --save\n\n\n\n\nProceed to the \nAPI\n reference.", 
            "title": "Home"
        }, 
        {
            "location": "/#eacjs", 
            "text": "A library and a command line execution tool for working with the  Ethereum Alarm Clock  protocol.", 
            "title": "eac.js"
        }, 
        {
            "location": "/#install", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/#as-an-executable", 
            "text": "The  eac.js  executable can be downloaded from NPM.   $ npm i -g eac.js  Please proceed to  Executing  for a walkthrough on how to get started.", 
            "title": "As an executable"
        }, 
        {
            "location": "/#as-a-library", 
            "text": "If you are using eac.js as a library you will want to download it into your  package.json  file.  $ npm i eac.js --save  Proceed to the  API  reference.", 
            "title": "As a library"
        }, 
        {
            "location": "/Executing_Tut/", 
            "text": "Running an Execution client with eac.js\n\n\nOne of the things you can do with the eac.js commandline tool\nis run an execution client. This client will scan the blockchain \nlooking for upcoming transaction requests and attempt to claim and \nexecute them. If the client successfully executes a transaction, it will\nbe rewarded with the \npayment\n that was set by the scheduler as well\nas reimbursed for all the gas costs. \n\n\nNote: Currenlty eac.js is only available for the Ropsten or Kovan testnet and only\nworks on a parity local node. Geth support is not available on the stable branch\nand is not recommended at this time.\n\n\nSetting up a Parity local node\n\n\nTo run the execution client on the commandline requires the set up of a \nParity local node on the Ropsten or Kovan test networks. This requirement is due to \nthe fact that the client relies on a Parity-specific API for checking\nthe transaction pool for existing calls to contracts. Without this \nRPC call, the client will try to send transactions on top of other clients\nwhich would invetibly lead to one of those calls being denied and thereby\nlosing the client some gas fees. You can download Parity by following the \ninstructions on their \ngithub\n.\n\n\nFor the sake of this tutorial, we will be using the Ropsten network, but all\nthe commands should work by specifying the Kovan network instead.\n\n\nWe begin by creating a new account.\n\n\n$ parity --chain ropsten account new\n\n\n\n\nThe command will prompt you to enter a new password. As with any password,\nmake sure you keep it in a secure place and do not lose it. It will also\nprint the address of your new ethereum account to the console. The next\ntime you start the parity client, and every time thereafter you will have\nto pass a command to make sure that this account is unlocked and able to\nsign and send transaction. You will also want to create a text file and save\npassword in it since parity requires it to unlock the account. Try \nrestarting parity again and unlocking the account:\n\n\n$ parity --geth --chain ropsten --unlock \nYOUR ACCOUNT\n --password \nPASSWORD FILE\n\n\n\n\n\nParity should continue syncing with your account unlocked. Your next\nsteps should be finding a source for some Ropsten Ether, try the \nMetamask\nfaucet\n or ask in the Ethereum Alarm Clock Gitter room.\n\n\nRunning the client\n\n\nYou can run the client using just your default account by simply passing the\n\n-c\n option to eac.js. The tool will automatically pickup which network you\nare using. It will drop you into a REPL that has a few speciic commands to\nhelp with interacting with the EAC.\n\n\n$ eac.js -c\n\u23f0\u23f0\u23f0 Welcome to the Ethereum Alarm Clock client \u23f0\u23f0\u23f0\n\nWallet support: Disabled\n\nExecuting from account:\n0x009f7EfeD908c05df5101DA1557b7CaaB38EE4Ce | Balance: 62.055242795864837678\n\n\n\n\n\n\n\nThe REPL is an important aspect of the eac.js tool and provides you\nwith a set of specific commands that will help you in interacting with\nand executing on the Ethereum Alarm Clock contracts. The EAC-centric commands \nyou can pass to this REPL are below:\n\n\n.dumpCache          Dumps your cache storage.\n.getBalance         Get the balance of your accounts.\n.getBlock           Get the latest blockNum and timestamp.\n.getStats           Get some interesting stats on your executing accounts.\n.logLevel \nnum\n     Defines the level to log, 1 - debug/cache, 2 - info, 3 - error.\n.requestInfo \naddr\n Retrieves some info about the transaction request at \naddr\n.\n.start              Starts the execution client.\n.stop               Stops the execution client.\n.sweepCache         Sweeps your cache of expired txRequests.\n.testTx             Send a test transaction to the network (requires unlocked local account).\n\n\n\n\nThe most important commands are probably \n.start\n and \n.stop\n which \nrespectively begins and pauses the execution clients. When you begin\nexecuting, you client will search the blockchain for upcoming transaction\nrequests registered with the Ethereum Alarm Clock contracts and store them\nin your local cache. It will then periodically scan your cache for actionable\ntransaction requests and perform one of three actions on them: claim, execute, or\ncleanup. If one of your accounts executes a transaction, it will earn money. You\ncan check on the stats of your executing accounts at any time by using the\n\n.getStats\n command. Likewise, you can view the contents of your cache by\nusing the \n.dumpCache\n command and if you would like to clear away old requests,\nuse \n.sweepCache\n (although the client will do this automatically every 12 minutes).\n\n\nIf you notice that the blockchain is sparse of upcoming transactions, you can \npopulate a test transaction by using the command \n.testTx\n. Note! This will use\nyour default unlocked account to send a transaction to the network so make sure\nyou have enough testnet ether in your account to do this.\n\n\nOne last note! The logs will be output to ~/.eac.log. You can follow the output\nby opening a new terminal screen and running \ntail -f ~/.eac.log\n. Remember that\nyou can change the logging output inside the REPL using the \n.logLevel \nnum\n\ncommand.\n\n\nAnd that's all there is to it. If you have any questions please join us on Gitter,\nor raise an issue on Github. Thanks for using the tool! \ud83d\ude42", 
            "title": "Executing"
        }, 
        {
            "location": "/Executing_Tut/#running-an-execution-client-with-eacjs", 
            "text": "One of the things you can do with the eac.js commandline tool\nis run an execution client. This client will scan the blockchain \nlooking for upcoming transaction requests and attempt to claim and \nexecute them. If the client successfully executes a transaction, it will\nbe rewarded with the  payment  that was set by the scheduler as well\nas reimbursed for all the gas costs.   Note: Currenlty eac.js is only available for the Ropsten or Kovan testnet and only\nworks on a parity local node. Geth support is not available on the stable branch\nand is not recommended at this time.", 
            "title": "Running an Execution client with eac.js"
        }, 
        {
            "location": "/Executing_Tut/#setting-up-a-parity-local-node", 
            "text": "To run the execution client on the commandline requires the set up of a \nParity local node on the Ropsten or Kovan test networks. This requirement is due to \nthe fact that the client relies on a Parity-specific API for checking\nthe transaction pool for existing calls to contracts. Without this \nRPC call, the client will try to send transactions on top of other clients\nwhich would invetibly lead to one of those calls being denied and thereby\nlosing the client some gas fees. You can download Parity by following the \ninstructions on their  github .  For the sake of this tutorial, we will be using the Ropsten network, but all\nthe commands should work by specifying the Kovan network instead.  We begin by creating a new account.  $ parity --chain ropsten account new  The command will prompt you to enter a new password. As with any password,\nmake sure you keep it in a secure place and do not lose it. It will also\nprint the address of your new ethereum account to the console. The next\ntime you start the parity client, and every time thereafter you will have\nto pass a command to make sure that this account is unlocked and able to\nsign and send transaction. You will also want to create a text file and save\npassword in it since parity requires it to unlock the account. Try \nrestarting parity again and unlocking the account:  $ parity --geth --chain ropsten --unlock  YOUR ACCOUNT  --password  PASSWORD FILE   Parity should continue syncing with your account unlocked. Your next\nsteps should be finding a source for some Ropsten Ether, try the  Metamask\nfaucet  or ask in the Ethereum Alarm Clock Gitter room.", 
            "title": "Setting up a Parity local node"
        }, 
        {
            "location": "/Executing_Tut/#running-the-client", 
            "text": "You can run the client using just your default account by simply passing the -c  option to eac.js. The tool will automatically pickup which network you\nare using. It will drop you into a REPL that has a few speciic commands to\nhelp with interacting with the EAC.  $ eac.js -c\n\u23f0\u23f0\u23f0 Welcome to the Ethereum Alarm Clock client \u23f0\u23f0\u23f0\n\nWallet support: Disabled\n\nExecuting from account:\n0x009f7EfeD908c05df5101DA1557b7CaaB38EE4Ce | Balance: 62.055242795864837678   The REPL is an important aspect of the eac.js tool and provides you\nwith a set of specific commands that will help you in interacting with\nand executing on the Ethereum Alarm Clock contracts. The EAC-centric commands \nyou can pass to this REPL are below:  .dumpCache          Dumps your cache storage.\n.getBalance         Get the balance of your accounts.\n.getBlock           Get the latest blockNum and timestamp.\n.getStats           Get some interesting stats on your executing accounts.\n.logLevel  num      Defines the level to log, 1 - debug/cache, 2 - info, 3 - error.\n.requestInfo  addr  Retrieves some info about the transaction request at  addr .\n.start              Starts the execution client.\n.stop               Stops the execution client.\n.sweepCache         Sweeps your cache of expired txRequests.\n.testTx             Send a test transaction to the network (requires unlocked local account).  The most important commands are probably  .start  and  .stop  which \nrespectively begins and pauses the execution clients. When you begin\nexecuting, you client will search the blockchain for upcoming transaction\nrequests registered with the Ethereum Alarm Clock contracts and store them\nin your local cache. It will then periodically scan your cache for actionable\ntransaction requests and perform one of three actions on them: claim, execute, or\ncleanup. If one of your accounts executes a transaction, it will earn money. You\ncan check on the stats of your executing accounts at any time by using the .getStats  command. Likewise, you can view the contents of your cache by\nusing the  .dumpCache  command and if you would like to clear away old requests,\nuse  .sweepCache  (although the client will do this automatically every 12 minutes).  If you notice that the blockchain is sparse of upcoming transactions, you can \npopulate a test transaction by using the command  .testTx . Note! This will use\nyour default unlocked account to send a transaction to the network so make sure\nyou have enough testnet ether in your account to do this.  One last note! The logs will be output to ~/.eac.log. You can follow the output\nby opening a new terminal screen and running  tail -f ~/.eac.log . Remember that\nyou can change the logging output inside the REPL using the  .logLevel  num \ncommand.  And that's all there is to it. If you have any questions please join us on Gitter,\nor raise an issue on Github. Thanks for using the tool! \ud83d\ude42", 
            "title": "Running the client"
        }, 
        {
            "location": "/API/", 
            "text": "API Documentation\n\n\nThe eac.js library provides utilies to interact with the Ethereum Alarm Clock contracts.\nIt exposes a few endpoints which mainly provide convenience wrappers over\nthe essiential functions of the contracts. \n\n\nIn general you will simply \nnpm install\n the \neac.js\n package then \nrequire\n it in your \nsource file. The module exports a function that accepts a Web3 object as its \nonly argument and returns the eac object. For backwards compability with pre-1.1.0\nAPI simply pass no argument into this function.\n\n\nconst Web3 = require(\nweb3\n)\nconst provider = new Web3.providers.HttpProvider('http://localhost:8545')\nconst web3 = new Web3(provider)\n\n// Initializes EAC for the contracts on the same chain as Web3 object.\nconst eac = require('eac.js')(web3)\n\n\n\n\nFor pre-1.1.0 API:\n\n\nconst eac = require('eac.js')()\n\n\n\n\nNote: The rest of this guide uses the latest API and assumes you instatiated\n\neac\n by passing in a web3 object.", 
            "title": "API Documentation"
        }, 
        {
            "location": "/API/#api-documentation", 
            "text": "The eac.js library provides utilies to interact with the Ethereum Alarm Clock contracts.\nIt exposes a few endpoints which mainly provide convenience wrappers over\nthe essiential functions of the contracts.   In general you will simply  npm install  the  eac.js  package then  require  it in your \nsource file. The module exports a function that accepts a Web3 object as its \nonly argument and returns the eac object. For backwards compability with pre-1.1.0\nAPI simply pass no argument into this function.  const Web3 = require( web3 )\nconst provider = new Web3.providers.HttpProvider('http://localhost:8545')\nconst web3 = new Web3(provider)\n\n// Initializes EAC for the contracts on the same chain as Web3 object.\nconst eac = require('eac.js')(web3)  For pre-1.1.0 API:  const eac = require('eac.js')()  Note: The rest of this guide uses the latest API and assumes you instatiated eac  by passing in a web3 object.", 
            "title": "API Documentation"
        }, 
        {
            "location": "/API/constants/", 
            "text": "eac.Constants\n\n\nconsole.log(eac.Constants)\n\n{\n    GT_HEX: \n0x3e\n,\n    LT_HEX: \n0x3c\n,\n    GTE_HEX: \n0x3e3d\n,\n    LTE_HEX: \n0x3c3d\n,\n    EQ_HEX: \n0x3d3d\n,\n    NULL_ADDRESS: \n0x0000000000000000000000000000000000000000\n,\n    EXECUTEDLOG:\n        \n0x3e504bb8b225ad41f613b0c3c4205cdd752d1615b4d77cd1773417282fcfb5d9\n,\n    ABORTEDLOG:\n        \n0xc008bc849b42227c61d5063a1313ce509a6e99211bfd59e827e417be6c65c81b\n,\n    NEWREQUESTLOG:\n        \n0x2749295aa7ffdbd4d16719dc03d592cd081eebd9bb790ceedce201a40675fc03\n,\n}", 
            "title": "Constants"
        }, 
        {
            "location": "/API/constants/#eacconstants", 
            "text": "console.log(eac.Constants)\n\n{\n    GT_HEX:  0x3e ,\n    LT_HEX:  0x3c ,\n    GTE_HEX:  0x3e3d ,\n    LTE_HEX:  0x3c3d ,\n    EQ_HEX:  0x3d3d ,\n    NULL_ADDRESS:  0x0000000000000000000000000000000000000000 ,\n    EXECUTEDLOG:\n         0x3e504bb8b225ad41f613b0c3c4205cdd752d1615b4d77cd1773417282fcfb5d9 ,\n    ABORTEDLOG:\n         0xc008bc849b42227c61d5063a1313ce509a6e99211bfd59e827e417be6c65c81b ,\n    NEWREQUESTLOG:\n         0x2749295aa7ffdbd4d16719dc03d592cd081eebd9bb790ceedce201a40675fc03 ,\n}", 
            "title": "eac.Constants"
        }, 
        {
            "location": "/API/requestFactory/", 
            "text": "eac.RequestFactory\n\n\nExposes utilities for interacting with the Request Factory contract.\n\n\nConstructor\n\n\nReturns a \nPromise\n that resolves a new instance of a \neac.RequestFactory\n\nclass. Uses the canonical Ethereum Alarm Clock contracts for the same \nchain as the Web3 object was initiated on.\n\n\n// Inside of an async function:\nconst requestFactory = await eac.requestFactory()\n\n\n\n\neac.RequestFactory.getTrackerAddress()\n\n\nReturns the \naddress\n of the tracker that the request factory is using\nto track new transaction requests. \n\n\nconst trackerAddr = requestFactory.getTrackerAddress()\n\n\n\n\neac.RequestFactory.isKnownRequest(requestAddr)\n\n\nTakes a \nTxRequest\n address and returns a \nPromise\n that will resolve \ntrue\n if the \ntransaction request is registed with the factory and \nfalse\n if it's not. \nThis function is used by clients to verify that the address was registered through\nthe watched contracts.\n\n\n// Verify that the request is known to the factory we are validating with.\nif (!await requestFactory.isKnownRequest(nextRequestAddress)) {\n    throw new Error(`Encountered unknown address! Please check that you are using the correct contracts JSON file.`)\n}\n\n\n\n\neac.RequestFactory.validateRequestParams(addressArgs, uintArgs, callData, endowment)\n\n\nLowest level validation function and takes the full request params\n\n\n\n\naddressArgs [0] -  meta.owner\n\n\naddressArgs [1] -  paymentData.donationBenefactor\n\n\naddressArgs [2] -  txnData.toAddress\n\n\nuintArgs [0]    -  paymentData.donation\n\n\nuintArgs [1]    -  paymentData.payment\n\n\nuintArgs [2]    -  schedule.claimWindowSize\n\n\nuintArgs [3]    -  schedule.freezePeriod\n\n\nuintArgs [4]    -  schedule.reservedWindowSize\n\n\nuintArgs [5]    -  schedule.temporalUnit\n\n\nuintArgs [6]    -  schedule.windowSize\n\n\nuintArgs [7]    -  schedule.windowStart\n\n\nuintArgs [8]    -  txnData.callGas\n\n\nuintArgs [9]    -  txnData.callValue\n\n\nuintArgs [10]   -  txnData.gasPrice\n\n\nuintArgs [11]   -  claimData.requiredDeposit\n\n\ncallData        -  The call data\n\n\nendowment       -  The value sent with the creation request.\n\n\n\n\nwhere \naddressArgs\n is an array of length 3 containing valid Ethereum addresses, \nuintArgs\n\nis an array of length 12 containing unsigned integers, the \ncallData\n is hex \nencoded and the \nendowment\n is a wei value. Returns an \nArray\nboolean\n of length 6,\nthe booleans will be true if validation passed and false if an error was triggered.\nUse \neac.RequestFactroy.parseIsValid()\n to parse error messages from this array.\n\n\neac.RequestFactory.parseIsValid(isValid)\n\n\nTakes an \nArray\nboolean\n of length six containing the results of \n.validateRequestParams()\n\nand returns an \nArray\nstring\n containig the parsed error messages.\n\n\nError messages include:\n * InsufficientEndowment\n * ReservedWindowBiggerThanExecutionWindow\n * InvalidTemporalUnit\n * ExecutionWindowTooSoon\n * CallGasTooHigh\n * EmptyToAddress\n\n\n// Defines the variables addressArgs, uintArgs, callData and endowment earlier in the file\nconst isValid = await requestFactory.validateRequestParams(\n    addressArgs,\n    uintArgs,\n    callData,\n    endowment\n)\n\nif (isValid.indexOf(false) != -1) {\n    const errorMsgs = requestFactory.parseIsValid(isValid)\n    throw new Error(errorMsgs)\n}\n\n\n\n\neac.RequestFactory.getRequestCreatedLogs(filter[,startBlock[, endBlock]])\n\n\nTakes a \nnumber\n \nstartBlock\n and optional \nnumber\n \nendBlock\n and returns\nthe raw logs for the requests created through the request factory between\nthese block times. If \nendBlock\n is not provided it will return all logs \nup until the \nlatest\n block. Returns a \nPromise\n that resolves to an array\nof the logs.\n\n\nconst logs = await requestFactory.getRequestCreatedLogs(5665000)\nconsole.log(logs)\n\n// [ { address: '0x209270d49a3673e8d6163849fa0539800cfeeb9c',\n//     blockHash: '0x94c1a6f26a765e47e72e77ce60d8c7ac4cb9dc5858e54bd04fffbc7ec4ce838e',\n//     blockNumber: 5665267,\n//     logIndex: 1,\n//     transactionHash: '0x1dfbd5f4e249fb211e9d4a0b47de54ea0380fc703773b0c393342de123be3d31',\n//     transactionIndex: 1,\n//     transactionLogIndex: '0x0',\n//     type: 'mined',\n//     event: 'RequestCreated',\n//     args: { request: '0x720704a706d8d6b01167d3a5723c1fa50b1aec28',\n//             owner: '0x92cb33fe17a75f0088a14c7718a29321fba026cd' } \n// } ]\n\n\n\n\neac.RequestFactory.getRequests(startBlock[, endBlock])\n\n\nSimilar to the previous function but returns an array of only the\naddresses of each transaction request. If not \nstarBlock\n or \nendBlock\n\nis provided,  will use \ncurrent block - 5000\n for startBlock and \nlatest\n\nfor endBlock.\n\n\nconst txRequests = await requestFactory.getRequests(5665000)\nconsole.log(txRequests)\n\n// [ '0x720704a706d8d6b01167d3a5723c1fa50b1aec28' ]\n\n\n\n\neac.RequestFactory.getRequestsByOwner(owner[, startBlock[, endBlock])\n\n\nTakes required argument \nowner\n which is a valid ethereum address\nand optional parameters \nstartBlock\n and \nendBlock\n. If \nstartBlock\n or\n\nendBlock\n are not provided uses the same defaults as \nthis.getRequests()\n. Returns a \nPromise\n which resolves to an array of transaction requests\naddresses which are \"owned\" (created by) the passed in address. If the \n\nowner\n address has not created any transaction requests then it will\nreturn an empty array.\n\n\nconst owner = \n0x92cb33fe17a75f0088a14c7718a29321fba026cd\n\nconst txRequests = await requestFactory.getRequestsByOwner(owner)\n\nconsole.log(txRequests)\n// [ '0xe8cf252bed6c94d7119d0154d9318aa03c6ff38c' ]\n\n// Then you can use it\nconst myRequest = await eac.transactionRequest(txRequests[0])", 
            "title": "Request Factory"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactory", 
            "text": "Exposes utilities for interacting with the Request Factory contract.", 
            "title": "eac.RequestFactory"
        }, 
        {
            "location": "/API/requestFactory/#constructor", 
            "text": "Returns a  Promise  that resolves a new instance of a  eac.RequestFactory \nclass. Uses the canonical Ethereum Alarm Clock contracts for the same \nchain as the Web3 object was initiated on.  // Inside of an async function:\nconst requestFactory = await eac.requestFactory()", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactorygettrackeraddress", 
            "text": "Returns the  address  of the tracker that the request factory is using\nto track new transaction requests.   const trackerAddr = requestFactory.getTrackerAddress()", 
            "title": "eac.RequestFactory.getTrackerAddress()"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryisknownrequestrequestaddr", 
            "text": "Takes a  TxRequest  address and returns a  Promise  that will resolve  true  if the \ntransaction request is registed with the factory and  false  if it's not. \nThis function is used by clients to verify that the address was registered through\nthe watched contracts.  // Verify that the request is known to the factory we are validating with.\nif (!await requestFactory.isKnownRequest(nextRequestAddress)) {\n    throw new Error(`Encountered unknown address! Please check that you are using the correct contracts JSON file.`)\n}", 
            "title": "eac.RequestFactory.isKnownRequest(requestAddr)"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryvalidaterequestparamsaddressargs-uintargs-calldata-endowment", 
            "text": "Lowest level validation function and takes the full request params   addressArgs [0] -  meta.owner  addressArgs [1] -  paymentData.donationBenefactor  addressArgs [2] -  txnData.toAddress  uintArgs [0]    -  paymentData.donation  uintArgs [1]    -  paymentData.payment  uintArgs [2]    -  schedule.claimWindowSize  uintArgs [3]    -  schedule.freezePeriod  uintArgs [4]    -  schedule.reservedWindowSize  uintArgs [5]    -  schedule.temporalUnit  uintArgs [6]    -  schedule.windowSize  uintArgs [7]    -  schedule.windowStart  uintArgs [8]    -  txnData.callGas  uintArgs [9]    -  txnData.callValue  uintArgs [10]   -  txnData.gasPrice  uintArgs [11]   -  claimData.requiredDeposit  callData        -  The call data  endowment       -  The value sent with the creation request.   where  addressArgs  is an array of length 3 containing valid Ethereum addresses,  uintArgs \nis an array of length 12 containing unsigned integers, the  callData  is hex \nencoded and the  endowment  is a wei value. Returns an  Array boolean  of length 6,\nthe booleans will be true if validation passed and false if an error was triggered.\nUse  eac.RequestFactroy.parseIsValid()  to parse error messages from this array.", 
            "title": "eac.RequestFactory.validateRequestParams(addressArgs, uintArgs, callData, endowment)"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryparseisvalidisvalid", 
            "text": "Takes an  Array boolean  of length six containing the results of  .validateRequestParams() \nand returns an  Array string  containig the parsed error messages.  Error messages include:\n * InsufficientEndowment\n * ReservedWindowBiggerThanExecutionWindow\n * InvalidTemporalUnit\n * ExecutionWindowTooSoon\n * CallGasTooHigh\n * EmptyToAddress  // Defines the variables addressArgs, uintArgs, callData and endowment earlier in the file\nconst isValid = await requestFactory.validateRequestParams(\n    addressArgs,\n    uintArgs,\n    callData,\n    endowment\n)\n\nif (isValid.indexOf(false) != -1) {\n    const errorMsgs = requestFactory.parseIsValid(isValid)\n    throw new Error(errorMsgs)\n}", 
            "title": "eac.RequestFactory.parseIsValid(isValid)"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactorygetrequestcreatedlogsfilterstartblock-endblock", 
            "text": "Takes a  number   startBlock  and optional  number   endBlock  and returns\nthe raw logs for the requests created through the request factory between\nthese block times. If  endBlock  is not provided it will return all logs \nup until the  latest  block. Returns a  Promise  that resolves to an array\nof the logs.  const logs = await requestFactory.getRequestCreatedLogs(5665000)\nconsole.log(logs)\n\n// [ { address: '0x209270d49a3673e8d6163849fa0539800cfeeb9c',\n//     blockHash: '0x94c1a6f26a765e47e72e77ce60d8c7ac4cb9dc5858e54bd04fffbc7ec4ce838e',\n//     blockNumber: 5665267,\n//     logIndex: 1,\n//     transactionHash: '0x1dfbd5f4e249fb211e9d4a0b47de54ea0380fc703773b0c393342de123be3d31',\n//     transactionIndex: 1,\n//     transactionLogIndex: '0x0',\n//     type: 'mined',\n//     event: 'RequestCreated',\n//     args: { request: '0x720704a706d8d6b01167d3a5723c1fa50b1aec28',\n//             owner: '0x92cb33fe17a75f0088a14c7718a29321fba026cd' } \n// } ]", 
            "title": "eac.RequestFactory.getRequestCreatedLogs(filter[,startBlock[, endBlock]])"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactorygetrequestsstartblock-endblock", 
            "text": "Similar to the previous function but returns an array of only the\naddresses of each transaction request. If not  starBlock  or  endBlock \nis provided,  will use  current block - 5000  for startBlock and  latest \nfor endBlock.  const txRequests = await requestFactory.getRequests(5665000)\nconsole.log(txRequests)\n\n// [ '0x720704a706d8d6b01167d3a5723c1fa50b1aec28' ]", 
            "title": "eac.RequestFactory.getRequests(startBlock[, endBlock])"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactorygetrequestsbyownerowner-startblock-endblock", 
            "text": "Takes required argument  owner  which is a valid ethereum address\nand optional parameters  startBlock  and  endBlock . If  startBlock  or endBlock  are not provided uses the same defaults as  this.getRequests() . Returns a  Promise  which resolves to an array of transaction requests\naddresses which are \"owned\" (created by) the passed in address. If the  owner  address has not created any transaction requests then it will\nreturn an empty array.  const owner =  0x92cb33fe17a75f0088a14c7718a29321fba026cd \nconst txRequests = await requestFactory.getRequestsByOwner(owner)\n\nconsole.log(txRequests)\n// [ '0xe8cf252bed6c94d7119d0154d9318aa03c6ff38c' ]\n\n// Then you can use it\nconst myRequest = await eac.transactionRequest(txRequests[0])", 
            "title": "eac.RequestFactory.getRequestsByOwner(owner[, startBlock[, endBlock])"
        }, 
        {
            "location": "/API/requestTracker/", 
            "text": "eac.RequestTracker\n\n\nExposes utilities for interacting with the Request Tracker contract.\n\n\nConstructor\n\n\nReturns a \nPromise\n that resolves a new instance of a \neac.RequestTracker\n\nclass. Uses the canonical Ethereum Alarm Clock contracts for the same\nchain as the Web3 object was initiated on.\n\n\n// Inside of an async function:\nconst requestTracker = await eac.requestTracker()\n\n\n\n\neac.RequestTracker.nextFromLeft(blockNum)\n\n\nTakes one argument, a \nblocknumber\n and queries the RequestTracker for \nthe next registered \nTxRequest\n at a windowstart greater than or equal \nto that block number. Returns a \nPromise\n which resolves to the the\ntransaction request \naddress\n.\n\n\nconst left = await eac.Util.getBlockNumber()\nconst nextRequestAddress = await requestTracker.nextFromLeft(left)\n\nconsole.log(nextRequestAddress)\n// 0x44Df...0Ba\n\n\n\n\neac.RequestTracker.windowStartFor(txRequestAddress)\n\n\nTakes one argument, the \naddress\n of a \nTxRequest\n and returns\na \nPromise\n that will resolve to  the \nwindowStart\n for that \ntransaction request.\n\n\nconst windowStart = await requestTracker.windowStartFor(nextRequestAddress)\nconsole.log(windowStart)\n\n// 5665000\n\n\n\n\neac.RequestTracker.nextRequest(txRequestAddress)\n\n\nTakes one argument, the \naddress\n of a \nTxRequest\n and returns\na \nPromise\n that resolves to the next registered transaction request \naddress, which can be used to create an instance of a \neac.TxRequest\n. \nWill resolve to a \nNULL_ADDRESS\n if there is not a next registered \ntransaction request.\n\n\nconst nextRequestAddress = await requestTracker.nextRequest(txRequest.address)\n\nif (nextRequestAddress === eac.Constants.NULL_ADDRESS) { \n    console.log('No new requests')\n}", 
            "title": "Request Tracker"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttracker", 
            "text": "Exposes utilities for interacting with the Request Tracker contract.", 
            "title": "eac.RequestTracker"
        }, 
        {
            "location": "/API/requestTracker/#constructor", 
            "text": "Returns a  Promise  that resolves a new instance of a  eac.RequestTracker \nclass. Uses the canonical Ethereum Alarm Clock contracts for the same\nchain as the Web3 object was initiated on.  // Inside of an async function:\nconst requestTracker = await eac.requestTracker()", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackernextfromleftblocknum", 
            "text": "Takes one argument, a  blocknumber  and queries the RequestTracker for \nthe next registered  TxRequest  at a windowstart greater than or equal \nto that block number. Returns a  Promise  which resolves to the the\ntransaction request  address .  const left = await eac.Util.getBlockNumber()\nconst nextRequestAddress = await requestTracker.nextFromLeft(left)\n\nconsole.log(nextRequestAddress)\n// 0x44Df...0Ba", 
            "title": "eac.RequestTracker.nextFromLeft(blockNum)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackerwindowstartfortxrequestaddress", 
            "text": "Takes one argument, the  address  of a  TxRequest  and returns\na  Promise  that will resolve to  the  windowStart  for that \ntransaction request.  const windowStart = await requestTracker.windowStartFor(nextRequestAddress)\nconsole.log(windowStart)\n\n// 5665000", 
            "title": "eac.RequestTracker.windowStartFor(txRequestAddress)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackernextrequesttxrequestaddress", 
            "text": "Takes one argument, the  address  of a  TxRequest  and returns\na  Promise  that resolves to the next registered transaction request \naddress, which can be used to create an instance of a  eac.TxRequest . \nWill resolve to a  NULL_ADDRESS  if there is not a next registered \ntransaction request.  const nextRequestAddress = await requestTracker.nextRequest(txRequest.address)\n\nif (nextRequestAddress === eac.Constants.NULL_ADDRESS) { \n    console.log('No new requests')\n}", 
            "title": "eac.RequestTracker.nextRequest(txRequestAddress)"
        }, 
        {
            "location": "/API/scheduler/", 
            "text": "eac.Scheduler\n\n\nThe Scheduler API of eac.js is a wrapper over both the Timestamp and \nBlock based scheduling APIS of the Ethereum Alarm Clock. It \nattempts to abstract most of the complexity away from the user\nso that you will only have to feed it the variables it wants.\n\n\nConstructor\n\n\nReturns a \nPromise\n that resolves a new instance of a \neac.Scheduler\n\nclass. Uses the canonical Ethereum Alarm Clock contracts for the same\nchain as the Web3 object was initiated on.\n\n\nconst eacScheduler = await eac.scheduler()\n\n\n\n\neac.Scheduler.getFactoryAddress()\n\n\nReturns a \nPromise\n that resolves to the \naddress\n of the \nRequest Factory being used by the Scheduler.\n\n\nconst factoryAddr = eacScheduler.getFactoryAddress()\n\nconst requestFactory = await eac.requestFactory()\n\nconsole.log(factoryAddr == requestFactory.address)\n// true\n\n\n\n\neac.Scheduler.initSender(opts)\n\n\nSets the sender for the scheduling transaction. The \nopts\n arguments is \na JSON that contains the \nfrom\n, \ngas\n, and \nvalue\n parameters of an \nEthereum transaction. See the example at the bottom for more context.\nNormally in web3 you would pass this object in as the lat argument\nto a \nweb3.eth.sendTransaction()\n call. eac.js requires you to pass\nit in before instead.\n\n\nSee the example below.\n\n\neac.Scheduler.blockSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)\n\n\n\n\ntoAddress\n     - an Ethereum address\n\n\ncallData\n      - hex encoded call data\n\n\ncallGas\n - \nBigNumber\n | String\n\n\ncallValue\n - \nBigNumber\n | String\n\n\nwindowSize\n - \nBigNumber\n | Stringn\n\n\nwindowStart\n - \nBigNumber\n | String\n\n\ngasPrice\n - \nBigNumber\n | String\n\n\ndonation\n - \nBigNumber\n | String\n\n\npayment\n - \nBigNumber\n | String\n\n\nrequiredDeposit\n - \nBigNumber\n | String\n\n\n\n\nReturns a \nPromise\n that will resolve to the \nreceipt\n of the transaction if successful.\n\n\nconst endowment = eac.Util.calcEndowment(\n    new BigNumber(callGas),\n    new BigNumber(callValue),\n    new BigNumber(gasPrice),\n    new BigNumber(donation),\n    new BigNumber(payment)\n)\n\neacScheduler.initSender({\n    from: web3.eth.defaultAccount,\n    gas: 3000000,\n    value: endowment\n})\n\nconst receipt = await eacScheduler.blockSchedule(\n    toAddress,\n    web3.fromAscii(callData),\n    callGas,\n    callValue,\n    windowSize,\n    windowStart,\n    gasPrice,\n    donation,\n    payment,\n    requiredDeposit\n)\n\n\n\n\neac.Scheduler.timestampSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)\n\n\n\n\ntoAddress\n     - an Ethereum address\n\n\ncallData\n      - hex encoded call data\n\n\ncallGas\n - \nBigNumber\n | String\n\n\ncallValue\n - \nBigNumber\n | String\n\n\nwindowSize\n - \nBigNumber\n | String\n\n\nwindowStart\n - \nBigNumber\n | String\n\n\ngasPrice\n - \nBigNumber\n | String\n\n\ndonation\n - \nBigNumber\n | String\n\n\npayment\n - \nBigNumber\n | String\n\n\nrequiredDeposit\n - \nBigNumber\n | String\n\n\n\n\nReturns a \nPromise\n that will resolve to the \nreceipt\n of the transaction if successful.", 
            "title": "Scheduler"
        }, 
        {
            "location": "/API/scheduler/#eacscheduler", 
            "text": "The Scheduler API of eac.js is a wrapper over both the Timestamp and \nBlock based scheduling APIS of the Ethereum Alarm Clock. It \nattempts to abstract most of the complexity away from the user\nso that you will only have to feed it the variables it wants.", 
            "title": "eac.Scheduler"
        }, 
        {
            "location": "/API/scheduler/#constructor", 
            "text": "Returns a  Promise  that resolves a new instance of a  eac.Scheduler \nclass. Uses the canonical Ethereum Alarm Clock contracts for the same\nchain as the Web3 object was initiated on.  const eacScheduler = await eac.scheduler()", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/scheduler/#eacschedulergetfactoryaddress", 
            "text": "Returns a  Promise  that resolves to the  address  of the \nRequest Factory being used by the Scheduler.  const factoryAddr = eacScheduler.getFactoryAddress()\n\nconst requestFactory = await eac.requestFactory()\n\nconsole.log(factoryAddr == requestFactory.address)\n// true", 
            "title": "eac.Scheduler.getFactoryAddress()"
        }, 
        {
            "location": "/API/scheduler/#eacschedulerinitsenderopts", 
            "text": "Sets the sender for the scheduling transaction. The  opts  arguments is \na JSON that contains the  from ,  gas , and  value  parameters of an \nEthereum transaction. See the example at the bottom for more context.\nNormally in web3 you would pass this object in as the lat argument\nto a  web3.eth.sendTransaction()  call. eac.js requires you to pass\nit in before instead.  See the example below.", 
            "title": "eac.Scheduler.initSender(opts)"
        }, 
        {
            "location": "/API/scheduler/#eacschedulerblockscheduletoaddress-calldata-callgas-callvalue-windowsize-windowstart-gasprice-donation-payment-requireddeposit", 
            "text": "toAddress      - an Ethereum address  callData       - hex encoded call data  callGas  -  BigNumber  | String  callValue  -  BigNumber  | String  windowSize  -  BigNumber  | Stringn  windowStart  -  BigNumber  | String  gasPrice  -  BigNumber  | String  donation  -  BigNumber  | String  payment  -  BigNumber  | String  requiredDeposit  -  BigNumber  | String   Returns a  Promise  that will resolve to the  receipt  of the transaction if successful.  const endowment = eac.Util.calcEndowment(\n    new BigNumber(callGas),\n    new BigNumber(callValue),\n    new BigNumber(gasPrice),\n    new BigNumber(donation),\n    new BigNumber(payment)\n)\n\neacScheduler.initSender({\n    from: web3.eth.defaultAccount,\n    gas: 3000000,\n    value: endowment\n})\n\nconst receipt = await eacScheduler.blockSchedule(\n    toAddress,\n    web3.fromAscii(callData),\n    callGas,\n    callValue,\n    windowSize,\n    windowStart,\n    gasPrice,\n    donation,\n    payment,\n    requiredDeposit\n)", 
            "title": "eac.Scheduler.blockSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)"
        }, 
        {
            "location": "/API/scheduler/#eacschedulertimestampscheduletoaddress-calldata-callgas-callvalue-windowsize-windowstart-gasprice-donation-payment-requireddeposit", 
            "text": "toAddress      - an Ethereum address  callData       - hex encoded call data  callGas  -  BigNumber  | String  callValue  -  BigNumber  | String  windowSize  -  BigNumber  | String  windowStart  -  BigNumber  | String  gasPrice  -  BigNumber  | String  donation  -  BigNumber  | String  payment  -  BigNumber  | String  requiredDeposit  -  BigNumber  | String   Returns a  Promise  that will resolve to the  receipt  of the transaction if successful.", 
            "title": "eac.Scheduler.timestampSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)"
        }, 
        {
            "location": "/API/txRequest/", 
            "text": "eac.TxRequest\n\n\nThe wrapper class over an instance of a future transaction scheduled\nby the Ethereum Alarm Clock. Opens up getters to retrieve information\nabout the transaction request and methods for important actions.\n\n\nConstructor\n\n\nReturns a \nPromise\n that resolves a new instance of a \neac.TxRequest\n\nclass. Uses the canonical Ethereum Alarm Clock contracts for the \nsame chain as the Web3 object was initiated on. Requires one argument,\nthe address of the transaction request.\n\n\nconst txRequest = await eac.transactionRequest(address)\n\n// You now have a new transaction request object, the first thing\n// you will likely want to do it is fill its data.\n\n\n\n\neac.TxRequest.fillData()\n\n\nAsync function which will return a \nPromise\n that resolves to \ntrue\n if the \ndata is successfully fetched from the EAC contracts and stored in the \n\nTxRequest\n instance. You will need to call \n.fillData()\n before trying\nto access any of the methods of the transaction request since\nthe data starts out as \nempty\n.\n\n\nconsole.log(txRequest.isClaimed)   // undefined, must call `.fillData() first\nawait txRequest.fillData()\nconsole.log(txRequest.isClaimed)   // true\nconsole.log(txRequest.windowStart) // 2300780\n\n\n\n\neac.TxRequest.refreshData()\n\n\nAsync function that will return a \nPromise\n that resolves to \ntrue\n if the\ndata is successfully refreshed/updated. Use this method after you \nhave already filled the data on a transaction request and want to \nupdate its values. For example, you might use it if the transaction \nrequest was recently cancelled.\n\n\nconsole.log(txReqeuest.isCancelled) //false\n\nawait txRequest.cancel({\n    from: web3.eth.defaultAccount,\n    value: 0,\n    gas: 3000000,\n    gasPrice: web3.toWei('20', 'gwei')\n})\n\n// Outdated data\nconsole.log(txReqeuest.isCancelled) //false\n\n// Must refresh the data now.\nawait txRequest.refreshData()\nconsole.log(txRequest.isCancelled) //true\n\n\n\n\neac.TxRequest.now()\n\n\nReturns a \nPromise\n that will resolve to the \nblockNumber\n or \ntimestamp\n\nof the latest ethereum block, depnding on the internal \ntemporalUnit\n of\nthe transaction request.\n\n\neac.TxRequest.beforeClaimWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis not yet in the claim window and \nfalse\n if is after the claim window start. You can check\nthe claim window start time by using the property \neac.TxRequest.claimWindowStart\n.\n\n\neac.TxRequest.inClaimWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis inside the claim window and \nfalse\n if not. You could also determine this yourself\nusing the property \neac.TxRequest.claimWindowEnd\n which would return the claim window\nend time.\n\n\neac.TxRequest.inFreezePeriod()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis currently in the freeze (aka lock-down) period and \nfalse\n if not.\n\n\neac.TxRequest.inExecutionWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently in the execution window and \nfalse\n if not.\n\n\neac.TxRequest.inReservedWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently in the reserved execution window and \nfalse\n if not. The reserved execution\nwindow is the first portion of the execution window which is reserved to be executed\nby the account that has claimed it in the previous claim window.\n\n\neac.TxRequest.afterExecutionWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently after the execution window and \nfalse\n if not.\n\n\neac.TxRequest.claimedBy\n\n\nProperty that returns the \naccount\n that has claimed the transaction request.\n\n\neac.TxRequest.isClaimed\n\n\nProperty that returns \ntrue\n if the transaction request is claimed.\n\n\neac.TxRequest.isClaimedBy(account)\n\n\nMethod that returns \ntrue\n if the transaction request is claimed by\nthe passed in \naccount\n argument.\n\n\neac.TxRequest.requiredDeposit\n\n\nProperty that returns a \nBigNumber\n containing the required deposit\nthat must be sent with the \nclaim()\n transaction in order for\nan account to claim a transaction request.\n\n\neac.TxRequest.claimPaymentModifier()\n\n\nMethod that returns a \nPromise\n that will resolve to a \nBigNumber\n containing\nthe payment modifier for the current time during the claim period. The claim\npayment starts at 0% and increases to 100% during the claim window. This method\nwill return that number.\n\n\neac.TxRequest.isCancelled\n\n\nProperty that returns \ntrue\n if the transaction request has been cancelled\nby its owner.\n\n\neac.TxRequest.wasCalled\n\n\nProperty that returns \ntrue\n if the transaction request has already\nbeen executed.\n\n\neac.TxRequest.owner\n\n\nProperty that returns the \naddress\n of the owner/creator of the transaction request.\n\n\neac.TxRequest.toAddress\n\n\nReturns the \naddress\n that the transaction request will be send to when it is executed.\n\n\neac.TxRequest.callGas\n\n\nReturns the a \nBigNumber\n containing the \ncallGas\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.callValue\n\n\nReturns the a \nBigNumber\n containing the \ncallValue\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.gasPrice\n\n\nReturns the a \nBigNumber\n containing the \ngasPrice\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.donation\n\n\nReturns the a \nBigNumber\n containing the \ndonation\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.payment\n\n\nReturns the a \nBigNumber\n containing the \npayment\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.callData()\n\n\nReturns a \nPromise\n that will resolve to the \ncallData\n that the \ntransaction requestwill send when its executed.\n\n\neac.TxRequest.claim(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to claim a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.\n\n\neac.TxRequest.execute(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to execute a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.\n\n\neac.TxRequest.cancel(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to cancel a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.", 
            "title": "Transaction Request"
        }, 
        {
            "location": "/API/txRequest/#eactxrequest", 
            "text": "The wrapper class over an instance of a future transaction scheduled\nby the Ethereum Alarm Clock. Opens up getters to retrieve information\nabout the transaction request and methods for important actions.", 
            "title": "eac.TxRequest"
        }, 
        {
            "location": "/API/txRequest/#constructor", 
            "text": "Returns a  Promise  that resolves a new instance of a  eac.TxRequest \nclass. Uses the canonical Ethereum Alarm Clock contracts for the \nsame chain as the Web3 object was initiated on. Requires one argument,\nthe address of the transaction request.  const txRequest = await eac.transactionRequest(address)\n\n// You now have a new transaction request object, the first thing\n// you will likely want to do it is fill its data.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestfilldata", 
            "text": "Async function which will return a  Promise  that resolves to  true  if the \ndata is successfully fetched from the EAC contracts and stored in the  TxRequest  instance. You will need to call  .fillData()  before trying\nto access any of the methods of the transaction request since\nthe data starts out as  empty .  console.log(txRequest.isClaimed)   // undefined, must call `.fillData() first\nawait txRequest.fillData()\nconsole.log(txRequest.isClaimed)   // true\nconsole.log(txRequest.windowStart) // 2300780", 
            "title": "eac.TxRequest.fillData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestrefreshdata", 
            "text": "Async function that will return a  Promise  that resolves to  true  if the\ndata is successfully refreshed/updated. Use this method after you \nhave already filled the data on a transaction request and want to \nupdate its values. For example, you might use it if the transaction \nrequest was recently cancelled.  console.log(txReqeuest.isCancelled) //false\n\nawait txRequest.cancel({\n    from: web3.eth.defaultAccount,\n    value: 0,\n    gas: 3000000,\n    gasPrice: web3.toWei('20', 'gwei')\n})\n\n// Outdated data\nconsole.log(txReqeuest.isCancelled) //false\n\n// Must refresh the data now.\nawait txRequest.refreshData()\nconsole.log(txRequest.isCancelled) //true", 
            "title": "eac.TxRequest.refreshData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestnow", 
            "text": "Returns a  Promise  that will resolve to the  blockNumber  or  timestamp \nof the latest ethereum block, depnding on the internal  temporalUnit  of\nthe transaction request.", 
            "title": "eac.TxRequest.now()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestbeforeclaimwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis not yet in the claim window and  false  if is after the claim window start. You can check\nthe claim window start time by using the property  eac.TxRequest.claimWindowStart .", 
            "title": "eac.TxRequest.beforeClaimWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinclaimwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis inside the claim window and  false  if not. You could also determine this yourself\nusing the property  eac.TxRequest.claimWindowEnd  which would return the claim window\nend time.", 
            "title": "eac.TxRequest.inClaimWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinfreezeperiod", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis currently in the freeze (aka lock-down) period and  false  if not.", 
            "title": "eac.TxRequest.inFreezePeriod()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinexecutionwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently in the execution window and  false  if not.", 
            "title": "eac.TxRequest.inExecutionWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinreservedwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently in the reserved execution window and  false  if not. The reserved execution\nwindow is the first portion of the execution window which is reserved to be executed\nby the account that has claimed it in the previous claim window.", 
            "title": "eac.TxRequest.inReservedWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestafterexecutionwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently after the execution window and  false  if not.", 
            "title": "eac.TxRequest.afterExecutionWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimedby", 
            "text": "Property that returns the  account  that has claimed the transaction request.", 
            "title": "eac.TxRequest.claimedBy"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestisclaimed", 
            "text": "Property that returns  true  if the transaction request is claimed.", 
            "title": "eac.TxRequest.isClaimed"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestisclaimedbyaccount", 
            "text": "Method that returns  true  if the transaction request is claimed by\nthe passed in  account  argument.", 
            "title": "eac.TxRequest.isClaimedBy(account)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestrequireddeposit", 
            "text": "Property that returns a  BigNumber  containing the required deposit\nthat must be sent with the  claim()  transaction in order for\nan account to claim a transaction request.", 
            "title": "eac.TxRequest.requiredDeposit"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimpaymentmodifier", 
            "text": "Method that returns a  Promise  that will resolve to a  BigNumber  containing\nthe payment modifier for the current time during the claim period. The claim\npayment starts at 0% and increases to 100% during the claim window. This method\nwill return that number.", 
            "title": "eac.TxRequest.claimPaymentModifier()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestiscancelled", 
            "text": "Property that returns  true  if the transaction request has been cancelled\nby its owner.", 
            "title": "eac.TxRequest.isCancelled"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestwascalled", 
            "text": "Property that returns  true  if the transaction request has already\nbeen executed.", 
            "title": "eac.TxRequest.wasCalled"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestowner", 
            "text": "Property that returns the  address  of the owner/creator of the transaction request.", 
            "title": "eac.TxRequest.owner"
        }, 
        {
            "location": "/API/txRequest/#eactxrequesttoaddress", 
            "text": "Returns the  address  that the transaction request will be send to when it is executed.", 
            "title": "eac.TxRequest.toAddress"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcallgas", 
            "text": "Returns the a  BigNumber  containing the  callGas  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.callGas"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcallvalue", 
            "text": "Returns the a  BigNumber  containing the  callValue  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.callValue"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestgasprice", 
            "text": "Returns the a  BigNumber  containing the  gasPrice  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.gasPrice"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestdonation", 
            "text": "Returns the a  BigNumber  containing the  donation  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.donation"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestpayment", 
            "text": "Returns the a  BigNumber  containing the  payment  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.payment"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcalldata", 
            "text": "Returns a  Promise  that will resolve to the  callData  that the \ntransaction requestwill send when its executed.", 
            "title": "eac.TxRequest.callData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to claim a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.claim(params)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestexecuteparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to execute a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.execute(params)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcancelparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to cancel a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.cancel(params)"
        }, 
        {
            "location": "/API/util/", 
            "text": "eac.Util\n\n\nProvides convenience and utility functions for working with web3\nand the Ethereum Alarm Clock contracts. The nice part about this module \nis that it uses the same web3 object provided during the initiation\nof \neac.js\n and provides Promise wrappers over Web3 callbacks.\n\n\neac.Util.calcEndowment(callGas, callValue, gasPrice, donation, payment)\n\n\nTakes in \nString|Number|BigNumber\n arguments for \ncallGas\n, \ncallValue\n,\n\ngasPrice\n, \ndonation\n and \npayment\n variables of a to-be scheduled\ntransaction and returns a \nBigNumber\n of the required endowment to be\nsent to successful send the scheduling transaction.\n\n\nSee \nhere\n under \neac.Scheduler.blockSchedule()\n for an example\n\n\neac.Util.checkNotNullAddress(address)\n\n\nReturns \ntrue\n if the address is not equal to the NULL_ADDRESS (0x0...0)\nand \nfalse\n if the address is the NULL_ADDRESS.\n\n\neac.Util.checkValidAddress(address)\n\n\nSimilar to \n.checkNotNullAddress()\n but performs a checksum validation \nas well to make the address is valid. Returns \ntrue\n if it passes and\n\nfalse\n if validation fails.\n\n\neac.Util.estimateGas(opts)\n\n\nTakes \nopts\n variable being the options to an Ethereum transaction in JSON\nform. EX.\n\n\n{\n    from: web3.eth.defaultAccount,\n    to: requestFactory.address,\n    data: 0xF620Abcc...\n}\n\n\n\n\nand returns a \nPromise\n that will resolve to the estimated gas cost of\nthe transaction or reject with an error.\n\n\neac.Util.getBalance(address)\n\n\nTakes a valid Ethereum \naddress\n and returns a \nPromise\n that will resolve\nto a \nBigNumber\n of the balance of that address in wei.\n\n\neac.Util.getBlockNumber()\n\n\nReturns a \nPromise\n that resolves to the latest block number.\n\n\neac.Util.getGasPrice()\n\n\nReturns a \nPromise\n that resolves to the latest average estimated\ngas price.\n\n\neac.Util.getTimestamp()\n\n\nReturns a \nPromise\n that resolves to the timestamp of the latest\nblock.\n\n\neac.Util.getTimestampForBlock(blockNum)\n\n\nTakes a block number \nblockNum\n and returns a \nPromise\n that will resolve\nto the timestamp of that block or reject the error.\n\n\neac.Util.getTxRequestFromReceipt(receipt)\n\n\nTakes the \nreceipt\n from a \neac.Scheduler.schedule()\n transaction and\npulls out the address of the transaction request that was scheduled in\nthat scheduling transaction.", 
            "title": "Util"
        }, 
        {
            "location": "/API/util/#eacutil", 
            "text": "Provides convenience and utility functions for working with web3\nand the Ethereum Alarm Clock contracts. The nice part about this module \nis that it uses the same web3 object provided during the initiation\nof  eac.js  and provides Promise wrappers over Web3 callbacks.", 
            "title": "eac.Util"
        }, 
        {
            "location": "/API/util/#eacutilcalcendowmentcallgas-callvalue-gasprice-donation-payment", 
            "text": "Takes in  String|Number|BigNumber  arguments for  callGas ,  callValue , gasPrice ,  donation  and  payment  variables of a to-be scheduled\ntransaction and returns a  BigNumber  of the required endowment to be\nsent to successful send the scheduling transaction.  See  here  under  eac.Scheduler.blockSchedule()  for an example", 
            "title": "eac.Util.calcEndowment(callGas, callValue, gasPrice, donation, payment)"
        }, 
        {
            "location": "/API/util/#eacutilchecknotnulladdressaddress", 
            "text": "Returns  true  if the address is not equal to the NULL_ADDRESS (0x0...0)\nand  false  if the address is the NULL_ADDRESS.", 
            "title": "eac.Util.checkNotNullAddress(address)"
        }, 
        {
            "location": "/API/util/#eacutilcheckvalidaddressaddress", 
            "text": "Similar to  .checkNotNullAddress()  but performs a checksum validation \nas well to make the address is valid. Returns  true  if it passes and false  if validation fails.", 
            "title": "eac.Util.checkValidAddress(address)"
        }, 
        {
            "location": "/API/util/#eacutilestimategasopts", 
            "text": "Takes  opts  variable being the options to an Ethereum transaction in JSON\nform. EX.  {\n    from: web3.eth.defaultAccount,\n    to: requestFactory.address,\n    data: 0xF620Abcc...\n}  and returns a  Promise  that will resolve to the estimated gas cost of\nthe transaction or reject with an error.", 
            "title": "eac.Util.estimateGas(opts)"
        }, 
        {
            "location": "/API/util/#eacutilgetbalanceaddress", 
            "text": "Takes a valid Ethereum  address  and returns a  Promise  that will resolve\nto a  BigNumber  of the balance of that address in wei.", 
            "title": "eac.Util.getBalance(address)"
        }, 
        {
            "location": "/API/util/#eacutilgetblocknumber", 
            "text": "Returns a  Promise  that resolves to the latest block number.", 
            "title": "eac.Util.getBlockNumber()"
        }, 
        {
            "location": "/API/util/#eacutilgetgasprice", 
            "text": "Returns a  Promise  that resolves to the latest average estimated\ngas price.", 
            "title": "eac.Util.getGasPrice()"
        }, 
        {
            "location": "/API/util/#eacutilgettimestamp", 
            "text": "Returns a  Promise  that resolves to the timestamp of the latest\nblock.", 
            "title": "eac.Util.getTimestamp()"
        }, 
        {
            "location": "/API/util/#eacutilgettimestampforblockblocknum", 
            "text": "Takes a block number  blockNum  and returns a  Promise  that will resolve\nto the timestamp of that block or reject the error.", 
            "title": "eac.Util.getTimestampForBlock(blockNum)"
        }, 
        {
            "location": "/API/util/#eacutilgettxrequestfromreceiptreceipt", 
            "text": "Takes the  receipt  from a  eac.Scheduler.schedule()  transaction and\npulls out the address of the transaction request that was scheduled in\nthat scheduling transaction.", 
            "title": "eac.Util.getTxRequestFromReceipt(receipt)"
        }, 
        {
            "location": "/GUI_Implementer_Guide/", 
            "text": "Ethereum Alarm Clock GUI Implementation Guide\n\n\nThis guide is an attempt to provide information to ease the process of an implementation of a graphical front-end on the Ethereum Alarm Clock service. It should be a document that you can consult to understand what parameters you need to include and the user cases to cover while building your interface.\n\n\nWhat will be implemented?\n\n\nA graphical interface to the Ethereum Alarm Clock. User functionalities will include the ability to schedule a transaction in a cohesive flow. It may also include the ability to manually execute a transaction request (althought for the most past this will be done more efficiently by clients such as \neac.js\n)\n\n\nBasics\n\n\nThe ethereum alarm clock consists of a collection of smart contracts that interoperate with each other on-chain. Whenever a user schedules a new transaction, it will use these contracts to deploy a new contract that contains all of the execution data set by the user. The contracts keep track of this \ntransaction request\n in a database contract that exposes a public API to be queriable by off-chain code.\n\n\nServers that are running an execution client will be scanning the blockchain for scheduled \ntransaction requests\n and sending claim or execution transactions to them. Clients will be doing most of the execution work \"behind the scenes\" for users and ideally, they will never have to worry about their transaction being executed on time.\n\n\nIn order to provide incentive to execution clients, when users schedule transactions they will include a \npayment\n variable.\n\n\nIf you would like a complete introduction to the Ethereum Alarm Clock infrastructure, we recommend the official docs.\n\n\nSchedulers\n\n\nYou will be working with the high-level APIs of the Scheduler contracts. There are two types of Scheduler, a \nTimestampScheduler\n and a \nBlockScheduler\n. The only difference between these two is the unit of time that each accepts for its scheduling paremeters. As you might guess, the \nTimestampScheduler\n requires all input to be as a \nUnix timestamp\n while the \nBlockScheduler\n takes in input as Ethereum block numbers. Otherwise, both Schedulers have the same public function \nschedule()\n to accept input. Here is the Solidity interface:\n\n\nfunction schedule(address   _toAddress,\n                  bytes     _callData,\n                  uint[8]   _uintArgs)\n    doReset\n    public payable returns (address);\n\n\n\n\nSchedule params\n\n\nThe schedule function takes three parameters, an Ethereum address, an array of bytes (a Javascript \nBuffer\n), and an array of eight unsigned integers. The eight unsigned integers are:\n\n\n\n\n_uintArgs [0] The \ncallGas\n to be sent with the scheduled transaction.\n\n\n_uintArgs [1] The \ncallValue\n to be sent with the scheduled transaction.\n\n\n_uintArgs [2] The execution \nwindowSize\n.\n\n\n_uintArgs [3] The (block or timestamp) of the execution \nwindowStart\n.\n\n\n_uintArgs [4] The \ngasPrice\n which will be used to execute this transaction.\n\n\n_uintArgs [5] The \ndonation\n value attached to this transaction.\n\n\n_uintArgs [6] The \npayment\n value attached to this transaction.\n\n\n_uintArgs [7] The \nrequiredDeposit\n to claim this transaction.\n\n\n\n\nThe scheduling party must also send enough value to cover the \nendowment\n of the transaction request. The \nendowment\n is calculated like so:\n\n\nendowment = payment + donation * 2 + callGas * gasPrice + 180000 * gasPrice + callValue\n\n\n\n\nThe \nendowment\n is required because the scheduler of the transaction must pay all the gas costs, as well as cover the value and the \npayment\n and \ndonation\n costs up front.  \n\n\nValidation\n\n\nThe Schedulers will use the \nRequestFactory\n contract to perform some verification checks on the input it recieves and bubble up a \nValidationError\n event if one is encountered. The front-end GUI should be able to read these events if they happen and notify the use why their transaction was not able to go through. However, it may be better if the front-end code employed validation checks to prevent the error ever reaching the blockchain.\n\n\nSome verification check you will need to be aware of include:\n\n\nInsufficient Endowment\n\n\nThe amount sent in the transaction must be \nat least\n the sum computed as the \nendowment\n. \n\n\nCall Gas too High\n\n\nThe maximum callGas sent with the transaction is the \ncurrent_network_gasLimit - 140000\n where \n140000\n is the gas overhead of execution.\n\n\nEmpty To Address\n\n\nThe \ntoAddress\n cannot be a null address \n0x0000000000000000000000000000000000000000\n\n\nFor a full list of \nValidationError\n see \nthis page\n of the docs.\n\n\nNecessary Options\n\n\nYou will need to present an option for the user to switch between block-based\nscheduling and timestamp-based scheduling. This could be accomplished by the\nimplementation of a switch or checkbox, or perhaps a drop-down menu.\n\n\nTo be continued...", 
            "title": "GUI Implementer Guide"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#ethereum-alarm-clock-gui-implementation-guide", 
            "text": "This guide is an attempt to provide information to ease the process of an implementation of a graphical front-end on the Ethereum Alarm Clock service. It should be a document that you can consult to understand what parameters you need to include and the user cases to cover while building your interface.", 
            "title": "Ethereum Alarm Clock GUI Implementation Guide"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#what-will-be-implemented", 
            "text": "A graphical interface to the Ethereum Alarm Clock. User functionalities will include the ability to schedule a transaction in a cohesive flow. It may also include the ability to manually execute a transaction request (althought for the most past this will be done more efficiently by clients such as  eac.js )", 
            "title": "What will be implemented?"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#basics", 
            "text": "The ethereum alarm clock consists of a collection of smart contracts that interoperate with each other on-chain. Whenever a user schedules a new transaction, it will use these contracts to deploy a new contract that contains all of the execution data set by the user. The contracts keep track of this  transaction request  in a database contract that exposes a public API to be queriable by off-chain code.  Servers that are running an execution client will be scanning the blockchain for scheduled  transaction requests  and sending claim or execution transactions to them. Clients will be doing most of the execution work \"behind the scenes\" for users and ideally, they will never have to worry about their transaction being executed on time.  In order to provide incentive to execution clients, when users schedule transactions they will include a  payment  variable.  If you would like a complete introduction to the Ethereum Alarm Clock infrastructure, we recommend the official docs.", 
            "title": "Basics"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#schedulers", 
            "text": "You will be working with the high-level APIs of the Scheduler contracts. There are two types of Scheduler, a  TimestampScheduler  and a  BlockScheduler . The only difference between these two is the unit of time that each accepts for its scheduling paremeters. As you might guess, the  TimestampScheduler  requires all input to be as a  Unix timestamp  while the  BlockScheduler  takes in input as Ethereum block numbers. Otherwise, both Schedulers have the same public function  schedule()  to accept input. Here is the Solidity interface:  function schedule(address   _toAddress,\n                  bytes     _callData,\n                  uint[8]   _uintArgs)\n    doReset\n    public payable returns (address);", 
            "title": "Schedulers"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#schedule-params", 
            "text": "The schedule function takes three parameters, an Ethereum address, an array of bytes (a Javascript  Buffer ), and an array of eight unsigned integers. The eight unsigned integers are:   _uintArgs [0] The  callGas  to be sent with the scheduled transaction.  _uintArgs [1] The  callValue  to be sent with the scheduled transaction.  _uintArgs [2] The execution  windowSize .  _uintArgs [3] The (block or timestamp) of the execution  windowStart .  _uintArgs [4] The  gasPrice  which will be used to execute this transaction.  _uintArgs [5] The  donation  value attached to this transaction.  _uintArgs [6] The  payment  value attached to this transaction.  _uintArgs [7] The  requiredDeposit  to claim this transaction.   The scheduling party must also send enough value to cover the  endowment  of the transaction request. The  endowment  is calculated like so:  endowment = payment + donation * 2 + callGas * gasPrice + 180000 * gasPrice + callValue  The  endowment  is required because the scheduler of the transaction must pay all the gas costs, as well as cover the value and the  payment  and  donation  costs up front.", 
            "title": "Schedule params"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#validation", 
            "text": "The Schedulers will use the  RequestFactory  contract to perform some verification checks on the input it recieves and bubble up a  ValidationError  event if one is encountered. The front-end GUI should be able to read these events if they happen and notify the use why their transaction was not able to go through. However, it may be better if the front-end code employed validation checks to prevent the error ever reaching the blockchain.  Some verification check you will need to be aware of include:", 
            "title": "Validation"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#insufficient-endowment", 
            "text": "The amount sent in the transaction must be  at least  the sum computed as the  endowment .", 
            "title": "Insufficient Endowment"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#call-gas-too-high", 
            "text": "The maximum callGas sent with the transaction is the  current_network_gasLimit - 140000  where  140000  is the gas overhead of execution.", 
            "title": "Call Gas too High"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#empty-to-address", 
            "text": "The  toAddress  cannot be a null address  0x0000000000000000000000000000000000000000  For a full list of  ValidationError  see  this page  of the docs.", 
            "title": "Empty To Address"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#necessary-options", 
            "text": "You will need to present an option for the user to switch between block-based\nscheduling and timestamp-based scheduling. This could be accomplished by the\nimplementation of a switch or checkbox, or perhaps a drop-down menu.  To be continued...", 
            "title": "Necessary Options"
        }, 
        {
            "location": "/Changelog/", 
            "text": "Changelog\n\n\n1.1.\n\n\nUpdated the docs to use a new API that makes the module into an exported\nfunction instead of an object.\n\n\n0.9.8", 
            "title": "Changelog"
        }, 
        {
            "location": "/Changelog/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/Changelog/#11", 
            "text": "Updated the docs to use a new API that makes the module into an exported\nfunction instead of an object.", 
            "title": "1.1."
        }, 
        {
            "location": "/Changelog/#098", 
            "text": "", 
            "title": "0.9.8"
        }
    ]
}